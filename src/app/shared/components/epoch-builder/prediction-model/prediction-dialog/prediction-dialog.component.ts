import { Component, Inject, OnInit } from "@angular/core";
import {MatDialogRef, MAT_DIALOG_DATA} from "@angular/material/dialog";
import { BigNumber } from "bignumber.js";
import { ApexAxisChartSeries } from "ng-apexcharts";
import { 
	IPrediction, 
	IPredictionModelConfig, 
	PredictionService, 
	UtilsService 
} from "../../../../../core";
import { ChartService, IBarChartOptions, NavService } from "../../../../../services";
import { IPredictionDialogComponent, IPredictionDialogData } from "./interfaces";

@Component({
  selector: "app-prediction-dialog",
  templateUrl: "./prediction-dialog.component.html",
  styleUrls: ["./prediction-dialog.component.scss"]
})
export class PredictionDialogComponent implements OnInit, IPredictionDialogComponent {
	// Init main data
	public model!: IPredictionModelConfig;
	public prediction!: IPrediction;
	public featuresSum!: number;
	public features!: IBarChartOptions;


    constructor(
		public dialogRef: MatDialogRef<PredictionDialogComponent>,
		@Inject(MAT_DIALOG_DATA) private data: IPredictionDialogData,
		private _utils: UtilsService,
		public _nav: NavService,
		private _prediction: PredictionService,
		private _chart: ChartService
	) {}



    async ngOnInit(): Promise<void> {
		// Main Data
		this.model = this.data.model;
		this.prediction = this.data.prediction;
		this.featuresSum = <number>this._utils.outputNumber(BigNumber.sum.apply(null, this.prediction.f), { dp: 6 });

		// Build the chart
		let series: ApexAxisChartSeries = [];
		let colors: string[] = [];
		for (let i = 0; i < this.model.regressions.length; i++) {
			series.push({
				name: this.model.regressions[i].id.slice(0, 12),
				data: [ this.prediction.f[i] ]
			});
			let color: string = this._chart.neutralColor;
			if (this.prediction.f[i] > 0) { color = this._chart.upwardColor }
			if (this.prediction.f[i] < 0) { color = this._chart.downwardColor }
			colors.push(color);
		}
		this.features = this._chart.getBarChartOptions(
			{
				series: series, 
				colors: colors,
				xaxis: {categories: [ "Features" ], labels: {show: false}},
				//yaxis: {labels: {show: false}},
				plotOptions: { bar: { horizontal: false, columnWidth: "100%"}},
			}, 
			[ "Features" ], 
			300,
			undefined,
			//true,
			//{ min: -1, max: 1}
		);
		this.features.xaxis.axisBorder = {show: false};
		const self = this;
		this.features.chart.events = {
			click: function(e: any, cc: any, c: any) {
				if (c.dataPointIndex >= 0 && c.dataPointIndex < self.model.regressions.length) {
					self._nav.displayKerasModelDialog(self.model.regressions[c.dataPointIndex])
				}
			}
		};
    }












	/* Misc Helpers */



    // Tooltip
    public displayTooltip(): void {
        this._nav.displayTooltip("Prediction Model", [
            `The prediction model is an ensemble of regressions trained to predict Bitcoin's near-future trend. 
			Since the market is always changing, a complete recalibration is performed every few months.`,
            `The model predicts every ~10 seconds. Each prediction is broadcast, stored and used to create the 
            15-minute-interval candlesticks that are then used to calculate the trend state. The key pieces of 
            information derived from the model are:`,
            `1) Trend Sum: the sum of all the predictions generated by the regressions. This value can range from 0.000001 to 8 if the 
			model is predicting the trend will increase. It can also range from -0.000001 to -8 if the model is predicting the trend will 
			decrease.`,
            `2) Min Increase Sum: the trend sum at which the up-trend is considered to be very strong.`,
            `3) Min Decrease Sum: the trend sum at which the down-trend is considered to be very strong.`,
            `4) Trend State: the trend state makes use of a 32 hours window comprised by 15-minute-interval candlesticks in order to determine 
			if the trend is increasing or decreasing. This piece of data is useful to determine if a trend is getting stronger or weaker.`,
        ]);
    }




	/*
	* Closes the dialog.
	* @returns void
	* */
	public close(): void { this.dialogRef.close() }
}
