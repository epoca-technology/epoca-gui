import { IRegressionConfig } from "./regression";
import { IDiscovery } from "./discovery";
import { IEpochBuilderEvaluation } from "./epoch_builder_evaluation";



/* Prediction Model Types at _types/prediction_model_types.py */





/* Configuration */


/**
 * Min Sum Function
 * The prediction model"s discovery calculates the means and the medians of the 
 * successful predictions which then will be used to trade. For instance, If the 
 * mean function is selected, the model will make use of the discovery"s 
 * increase_successful_mean and the decrease_successful_mean as the minimum sums
 * in order to generate non-neutral predictions.
 */
export type IMinSumFunction = "mean"|"median";





/**
 * Regressions Per Model
 * The number of regressions that are placed in the prediction model.
 */
export type IRegressionsPerModel = 4|8|16;





/**
 * Minified Configuration
 * The minified configuration is used in order to narrow down the variations and
 * identify which models lead to profitability.
 */
export interface IPredictionModelMinifiedConfig {
    pcr: number,            // Price Change Requirement
    msf: IMinSumFunction,   // Min Sum Function
    msaf: number,           // Min Sum Adjustment Factor
    ri: string[]            // Regression IDs
}








/* Position Type */



/**
 * In futures markets, there can only be 2 types of positions:
 *  1: Long Position
 * -1: Short Position
 */
 export type IPositionType = 1|-1;
 







/* Prediction Object */




/**
 * When the model evaluates and predicts on current market data, outputs a result of 
 * 1 (long) or 0 (neutral) or -1 (short)
 */
 export type IPredictionResult = 1|0|-1;
 export type IPredictionResultName = "Long"|"Short"|"Neutral";
 export type IPredictionResultIcon = "trending_up"|"trending_down"|"trending_flat"
 

 
 
 
 /**
  * Prediction
  * The final prediction dict generated by the model. It contains the result, the time
  * in which the prediction was made and the list of features used to come to the result.
  */
 export interface IPrediction {
     // Prediction result: -1 | 0 | 1
     r: IPredictionResult,
 
     // The time in which the prediction was performed (milliseconds)
     t: number,
 
     // The list of predicted features 
     f: number[]
 }








 /* Backtest */




// Types of positions
export type IBacktestPositionType = 1|-1;





/**
 * Backtest Position
 * When a position is closed, it is saved in a list that can be reviewed in the GUI when
 * the backtest completes.
 */
export interface IBacktestPosition {
    // Type of position: 1 = long, -1 = short
    t: IBacktestPositionType,

    // Prediction Dict
    p: IPrediction,

    // Position Times
    ot: number,    // Open Timestamp
    ct: number,    // Close Timestamp - Populated when the position is closed

    // Position Prices
    op: number,   // Open Price
    tpp: number,  // Take Profit Price
    slp: number,  // Stop Loss Price

    // Close Price: This property is populated when a position is closed. It will
    // take value of the Take Profit Price or Stop Loss Price depending on the outcome.
    cp: number, 
    
    // The outcome is populated once the position is closed. True for successful and False
    // for unsuccessful
    o: boolean,

    // Balance when the position is closed
    b: number
}






/**
 * Backtest Performance
 * A dict containing all the information about the backtest executed on a model.
 */
export interface IBacktestPerformance {
    // General
    position_size: number,
    initial_balance: number,
    final_balance: number,
    profit: number,
    fees: number,
    leverage: number,
    exchange_fee: number,
    idle_minutes_on_position_close: number,

    // Positions
    positions: IBacktestPosition[],
    increase_num: number,
    decrease_num: number,
    increase_outcome_num: number,
    decrease_outcome_num: number,

    // Accuracy
    increase_accuracy: number,
    decrease_accuracy: number,
    accuracy: number,
}








 /* Prediction Model */




/**
 * Prediction Model Configuration
 * The configuration of the prediction model that is built for each profitable
 * model config. This dict is exported and used to initialize the Model in the
 * Prediction API.
 */
export interface IPredictionModelConfig {
    // Identity of the Model.
    id: string,

    // The price percentage change target
    price_change_requirement: number,

    // Sum function used to determine the min increase and decrease sums
    min_sum_function: IMinSumFunction,

    // The factor that is used to adjust the min sums
    min_sum_adjustment_factor: number,

    // The minimum increase and decrease sums required to generate non-neutral predictions
    min_increase_sum: number,
    min_decrease_sum: number,

    // The list of regressions in the model
    regressions: IRegressionConfig[]
}







/* Certificate */



/**
 * Prediction Model Certificate
 * Once the profitable model configs are built, a certificate is issued
 * for each one of them.
 */
export interface IPredictionModelCertificate {
    // Identity of the Model.
    id: string,

    // The date in which the model was created
    creation: number,

    // The date range from the epoch that was used to build the prediction models
    test_ds_start: number,
    test_ds_end: number,

    // The configuration of the model
    model: IPredictionModelConfig,

    // The discovery of the model
    discovery: IDiscovery,

    // The backtest performance of the model
    backtest: IBacktestPerformance,




    /**
     * GUI Properties
     * The following properties only exist in the GUI as they are populated
     * when certificates are loaded.
     */

    // Epoch Builder Evaluation
    ebe: IEpochBuilderEvaluation,

    // The value that will be used to order the certificates
    orderValue: number
}