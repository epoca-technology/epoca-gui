import { Injectable } from '@angular/core';
import { BigNumber } from "bignumber.js";
import { UtilsService } from '../../utils';
import { 
	IGeneralEvaluationItem, 
	IGeneralEvaluationStateClass, 
	IGeneralRegressionEvaluation, 
	IItemGeneralEvaluation, 
	IRegressionTrainingCertificate 
} from '../../prediction';
import { IRegressionTrainingEvaluationService } from './interfaces';

@Injectable({
  providedIn: 'root'
})
export class RegressionTrainingEvaluationService implements IRegressionTrainingEvaluationService{
	// The minimum points median accepted
	private readonly minPointsMedian: number = -40;

	// The minimum number of positions allowed
	private readonly minPositions: number = 70;

	// The minimum accuracy percentage allowed
	private readonly minAccuracy: number = 40;

	// The maximum percentage difference allowed for predictions vs outcomes
	private readonly maxPredictionDifference: number = 45;

	// Evaluation Template
	private evaluationTemplate: IGeneralRegressionEvaluation = {
		points: 0,
		max_points: 100,
		state_class: "error",
		items: [
			{
				id: "points_median",
				name: "Points Median",
				description: "Evaluates the median of the points collected in order to determine which models managed to sustain overtime.",
				state: "",
				points: 0,
				max_points: 25,
				state_class: "error"
			},
			{
				id: "long_accuracy",
				name: "Long Accuracy",
				description: "Evaluates the accuracy received in long predictions during the Regression Evaluation.\
				In the case of accuracy, the bigger the value the better.",
				state: "",
				points: 0,
				max_points: 4,
				state_class: "error"
			},
			{
				id: "short_accuracy",
				name: "Short Accuracy",
				description: "Evaluates the accuracy received in short predictions during the Regression Evaluation.\
				In the case of accuracy, the bigger the value the better.",
				state: "",
				points: 0,
				max_points: 4,
				state_class: "error"
			},
			{
				id: "general_accuracy",
				name: "General Accuracy",
				description: "Evaluates the accuracy received in general predictions during the Regression Evaluation.\
				In the case of accuracy, the bigger the value the better.",
				state: "",
				points: 0,
				max_points: 50,
				state_class: "error"
			},
			{
				id: "prediction_neutrality",
				name: "Prediction Neutrality",
				description: "Evaluates the number of non-neutral predictions generated by the model.",
				state: "",
				points: 0,
				max_points: 4,
				state_class: "error"
			},
			{
				id: "long_prediction_balance",
				name: "Long Prediction Balance",
				description: "Evaluates the balance of increase predictions generated by the model against the actual outcomes\
				during the regression evaluation. The smaller the distance between the prediction distribution and the \
				actual outcomes the better.",
				state: "",
				points: 0,
				max_points: 6.5,
				state_class: "error"
			},
			{
				id: "short_prediction_balance",
				name: "Short Prediction Balance",
				description: "Evaluates the balance of decrease predictions generated by the model against the actual outcomes\
				during the regression evaluation. The smaller the distance between the prediction distribution and the \
				actual outcomes the better.",
				state: "",
				points: 0,
				max_points: 6.5,
				state_class: "error"
			},
		]
	}

  	constructor(private _utils: UtilsService) { }





	/**
	 * Builds the general evaluation for a given certificate.
	 * @param cert 
	 * @returns IGeneralEvaluation
	 */
	 public buildGeneralEvaluation(cert: IRegressionTrainingCertificate): IGeneralRegressionEvaluation {
		// Init values
		let totalPoints: number = 0;
		let items: IGeneralEvaluationItem[] = [];

		// Iterate over each item
		for (let itemIndex = 0; itemIndex < this.evaluationTemplate.items.length; itemIndex++) {
			// Evaluate the item
			const { points, state, state_class } = this.evaluate(cert, this.evaluationTemplate.items[itemIndex]);

			// Increase the category points
			totalPoints += points;

			// Append the item to the list
			items.push({...this.evaluationTemplate.items[itemIndex], points: points, state: state, state_class: state_class});
		}

		// Finally, return the evaluation
		return {
			points: totalPoints,
			max_points: this.evaluationTemplate.max_points,
			state_class: this.getStateClass(totalPoints, this.evaluationTemplate.max_points),
			items: items
		}
	}








	/**
	 * Evaluates a given item accordingly based in its id.
	 * @param cert 
	 * @param item 
	 * @returns IItemGeneralEvaluation
	 */
	private evaluate(cert: IRegressionTrainingCertificate, item: IGeneralEvaluationItem): IItemGeneralEvaluation {
		// Check if the regression is broken
		const {broken, state} = this.isRegressionBroken(cert)

		if (item.id == "points_median") { return this.regressionPointsMedian(cert, item.max_points, broken, state) }
		else if (item.id == "long_accuracy") { return this.regressionEvaluationAccuracy(cert, item.max_points, "increase_acc", broken, state) }
		else if (item.id == "short_accuracy") { return this.regressionEvaluationAccuracy(cert, item.max_points, "decrease_acc", broken, state) }
		else if (item.id == "general_accuracy") { return this.regressionEvaluationAccuracy(cert, item.max_points, "acc", broken, state) }
		else if (item.id == "prediction_neutrality") { return this.predictionNeutrality(cert, item.max_points, broken, state) }
		else if (item.id == "long_prediction_balance") { return this.predictionBalance(cert, item.max_points, "increase", broken, state) }
		else if (item.id == "short_prediction_balance") { return this.predictionBalance(cert, item.max_points, "decrease", broken, state) }

		// Otherwise, something is wrong
		else { throw new Error(`The general evaluation item ${item.id} was not found.`) }
	}







	/**
	 * Performs a very general evaluation of the model and detects if it is broken.
	 * If so, all regression related evaluations should return no points in order
	 * to sink the model.
	 * @param cert 
	 * @returns {broken: boolean, state: string}
	 */
	private isRegressionBroken(cert: IRegressionTrainingCertificate): {broken: boolean, state: string} {
		// Init values
		let broken: boolean = false;
		let state: string = "";

		// Firstly, check the points median
		if (cert.regression_evaluation.points_median < this.minPointsMedian) {
			broken = true;
			state = `Broken Regression: the points median is unacceptable: ${cert.regression_evaluation.points_median}.`;
		}


		// Check the neutrality
		if (cert.regression_evaluation.positions.length < this.minPositions) {
			broken = true;
			state = `Broken Regression: the model only predicted ${cert.regression_evaluation.positions.length} non-neutral positions.`;
		}


		// Check the accuracies
		if (cert.regression_evaluation.increase_acc < this.minAccuracy) {
			broken = true;
			state = `Broken Regression: the increase accuracy is unacceptable: ${cert.regression_evaluation.increase_acc}%.`;
		}
		if (cert.regression_evaluation.decrease_acc < this.minAccuracy) {
			broken = true;
			state = `Broken Regression: the decrease accuracy is unacceptable: ${cert.regression_evaluation.decrease_acc}%.`;
		}
		if (cert.regression_evaluation.acc < this.minAccuracy) {
			broken = true;
			state = `Broken Regression: the accuracy is unacceptable: ${cert.regression_evaluation.acc}%.`;
		}


		// Check the increase predictions balance
		const increasePercentDifference: number = 
			this.getAbsoluteValue(<number>this._utils.calculatePercentageChange(
				cert.regression_evaluation.increase_num, 
				cert.regression_evaluation.increase_outcomes
			)
		);
		if (increasePercentDifference >= this.maxPredictionDifference) {
			broken = true;
			state = `Broken Regression: the increase prediction balance is unacceptable as the distance to the actual outcomes is 
			${increasePercentDifference}%.`;
		}

		// Check the decrease predictions balance
		const decreasePercentDifference: number = this.getAbsoluteValue(<number>this._utils.calculatePercentageChange(
				cert.regression_evaluation.decrease_num, 
				cert.regression_evaluation.decrease_outcomes
			)
		);
		if (decreasePercentDifference >= this.maxPredictionDifference) {
			broken = true;
			state = `Broken Regression: the decrease prediction balance is unacceptable as the distance to the actual outcomes is ${decreasePercentDifference}%.`;
		}

		// Return the final state
		return { broken: broken, state: state}
	}






	/**
	 * Evaluates the points median during the Regression Evaluation.
	 * @param cert
	 * @param maxPoints
	 * @param broken
	 * @param brokenState
	 * @returns IItemGeneralEvaluation
	 */
	 private regressionPointsMedian(
		cert: IRegressionTrainingCertificate, 
		maxPoints: number,
		broken: boolean,
		brokenState: string
   ): IItemGeneralEvaluation {
	   // Firstly, make sure the regression isnt broken
	   if (!broken) {
			// Init the points
			let points: number = 0;

			// Calculate the points 
			if (cert.regression_evaluation.points_median >= 10) { points = maxPoints }
			else if (cert.regression_evaluation.points_median >= 7) 	{ points = maxPoints/1.1 }
			else if (cert.regression_evaluation.points_median >= 5) 	{ points = maxPoints/1.2 }
			else if (cert.regression_evaluation.points_median >= 3) 	{ points = maxPoints/1.3 }
			else if (cert.regression_evaluation.points_median >= 1) 	{ points = maxPoints/1.4 }
			else if (cert.regression_evaluation.points_median >= 0) 	{ points = maxPoints/1.5 }
			else if (cert.regression_evaluation.points_median >= -1) 	{ points = maxPoints/2 }
			else if (cert.regression_evaluation.points_median >= -3) 	{ points = maxPoints/2.4 }
			else if (cert.regression_evaluation.points_median >= -5) 	{ points = maxPoints/2.7 }
			else if (cert.regression_evaluation.points_median >= -7) 	{ points = maxPoints/3 }
			else if (cert.regression_evaluation.points_median >= -9) 	{ points = maxPoints/3.5 }
			else if (cert.regression_evaluation.points_median >= -12) 	{ points = maxPoints/4 }
			else if (cert.regression_evaluation.points_median >= -15) 	{ points = maxPoints/4.5 }
			else if (cert.regression_evaluation.points_median >= -20) 	{ points = maxPoints/5 }
			else if (cert.regression_evaluation.points_median >= -25) 	{ points = maxPoints/6 }
			else  														{ points = maxPoints/10 }

			// Finally, return the results
			return {
				points: points, 
				state: `The evaluation concluded with a points median of ${cert.regression_evaluation.points_median}.`,
				state_class: this.getStateClass(points, maxPoints)
			}
	   } else { return { points: 0, state: brokenState, state_class: "error"} }
	}







	/**
	 * Evaluates the accuracy received in predictions during the Regression Evaluation.
	 * In the case of accuracy, the bigger the value the better.
	 * @param cert
	 * @param maxPoints
	 * @param predictionType
	 * @param broken
	 * @param brokenState
	 * @returns IItemGeneralEvaluation
	 */
	 private regressionEvaluationAccuracy(
		 cert: IRegressionTrainingCertificate, 
		 maxPoints: number,
		 predictionType: "increase_acc"|"decrease_acc"|"acc",
		 broken: boolean,
		 brokenState: string
	): IItemGeneralEvaluation {
		// Firstly, make sure the regression isnt broken
		if (!broken) {
			// Calculate the change
			const accuracy: number = cert.regression_evaluation[predictionType];

			// Check if there was an improvement
			if (accuracy >= 45) {
				const points: number = this.calculatePoints(accuracy, 45, 75, maxPoints)
				return {
					points: points, 
					state: `The evaluation concluded with an accuracy of ${accuracy}%.`,
					state_class: this.getStateClass(points, maxPoints)
				}
			} else {
				return {
					points: 0, 
					state: `The accuracy received in the regression evaluation is unacceptable (${accuracy}%).`, 
					state_class: "error"
				}
			}
		} else { return { points: 0, state: brokenState, state_class: "error"} }
	}





	/**
	 * Evaluates the number of non-neutral predictions generated by the model.
	 * @param cert 
	 * @param maxPoints 
	 * @param broken
	 * @param brokenState
	 * @returns IItemGeneralEvaluation
	 */
	private predictionNeutrality(
		cert: IRegressionTrainingCertificate, 
		maxPoints: number,
		broken: boolean,
		brokenState: string
	): IItemGeneralEvaluation {
		// Firstly, make sure the regression isn't broken
		if (!broken) {
			// Calculate the difference between the minimum and the actual positions
			const diff: number = cert.regression_evaluation.positions.length - this.minPositions;

			// Init the points
			let points: number = 0;
			if 			(diff >= 0) 	{ points = maxPoints }
			else if 	(diff >= -5) 	{ points = maxPoints/1.2 }
			else if 	(diff >= -10) 	{ points = maxPoints/1.4 }
			else if 	(diff >= -15) 	{ points = maxPoints/1.6 }
			else if 	(diff >= -20) 	{ points = maxPoints/1.8 }
			else if 	(diff >= -25) 	{ points = maxPoints/2 }
			else { points = maxPoints/5 }

			// Finally, return the evaluation
			return {
				points: points, 
				state: `The model generated ${cert.regression_evaluation.positions.length} non-neutral predictions.`,
				state_class: this.getStateClass(points, maxPoints)
			}
		} else { return { points: 0, state: brokenState, state_class: "error"} }
	}





	/**
	 * Evaluates the balance of predictions by type generated by the model against the actual outcomes
	 * during the regression evaluation. The smaller the distance between the prediction distribution and the 
	 * actual outcomes the better.
	 * @param cert 
	 * @param maxPoints 
	 * @param predictionType
	 * @param broken
	 * @param brokenState
	 * @returns  IItemGeneralEvaluation
	 */
	 private predictionBalance(
		 cert: IRegressionTrainingCertificate, 
		 maxPoints: number,
		 predictionType: "increase"|"decrease",
		 broken: boolean,
		 brokenState: string
	): IItemGeneralEvaluation {
		// Firstly, make sure the regression isn't broken
		if (!broken) {
			// Init the predictions and the outcomes
			const predictions: number = 
				predictionType == "increase" ? cert.regression_evaluation.increase_num: cert.regression_evaluation.decrease_num;
			const outcomes: number = 
				predictionType == "increase" ? cert.regression_evaluation.increase_outcomes: cert.regression_evaluation.decrease_outcomes;
			
			// Calculate the absolute change between the values
			const change: number = this.getAbsoluteValue(<number>this._utils.calculatePercentageChange(predictions, outcomes));

			// Calculate the points
			let points: number = 0;
			if 		(change > 29) 	{ points = maxPoints/7 }
			else if (change >= 27) 	{ points = maxPoints/6.5 }
			else if (change >= 25) 	{ points = maxPoints/6 }
			else if (change >= 24) 	{ points = maxPoints/5.8 }
			else if (change >= 23) 	{ points = maxPoints/5.5 }
			else if (change >= 22) 	{ points = maxPoints/5.2 }
			else if (change >= 21) 	{ points = maxPoints/4.8 }
			else if (change >= 20) 	{ points = maxPoints/4.5 }
			else if (change >= 19) 	{ points = maxPoints/4.2 }
			else if (change >= 18) 	{ points = maxPoints/3.9 }
			else if (change >= 17) 	{ points = maxPoints/3.6 }
			else if (change >= 16) 	{ points = maxPoints/3.3 }
			else if (change >= 15) 	{ points = maxPoints/3 }
			else if (change >= 14) 	{ points = maxPoints/2.8 }
			else if (change >= 13) 	{ points = maxPoints/2.6 }
			else if (change >= 12) 	{ points = maxPoints/2.4 }
			else if (change >= 11) 	{ points = maxPoints/2.2 }
			else if (change >= 10) 	{ points = maxPoints/2 }
			else if (change >= 9) 	{ points = maxPoints/1.9 }
			else if (change >= 8) 	{ points = maxPoints/1.8 }
			else if (change >= 7) 	{ points = maxPoints/1.7 }
			else if (change >= 6) 	{ points = maxPoints/1.6 }
			else if (change >= 5) 	{ points = maxPoints/1.5 }
			else if (change >= 4) 	{ points = maxPoints/1.4 }
			else if (change >= 3) 	{ points = maxPoints/1.3 }
			else if (change >= 2) 	{ points = maxPoints/1.2 }
			else if (change >= 1) 	{ points = maxPoints/1.1 }
			else 					{ points = maxPoints }

			// Finally, return the evaluation
			return {
				points: points, 
				state: `The prediction balance is ${change}% away from the actual outcomes.`,
				state_class: this.getStateClass(points, maxPoints)
			}
		} else { return { points: 0, state: brokenState, state_class: "error"} }
	}












	/* Point Calculations Helper */



	/**
	 * Calculates the total points accumulated by an evaluation based on the worst and best case. 
	 * Notice that the result will never be greater than maxPoints or less than 0.
	 * @param value 
	 * @param worstValue 
	 * @param bestValue 
	 * @param maxPoints 
	 * @returns number
	 */
	private calculatePoints(value: number, worstValue: number, bestValue: number, maxPoints: number): number {
		// Check if the value is equals or worse than the worstValue
		if (value <= worstValue) return 0;

		// Check if the value is equals or better than the bestValue
		if (value >= bestValue) return maxPoints;

		// Calculate the points
		const points: BigNumber = new BigNumber(value).times(maxPoints).dividedBy(bestValue);

		// Calculate the deserved points and return them
		return <number>this._utils.outputNumber(points, {dp: 2})
	}











	/* Misc Helpers */






	/**
	 * Returns the state class based on the points obtained.
	 * @param pointsReceived 
	 * @param maxPoints 
	 * @returns IGeneralEvaluationStateClass
	 */
	private getStateClass(pointsReceived: number, maxPoints: number): IGeneralEvaluationStateClass {
		// Calculate the percent received
		const pointsPercent: number = <number>this._utils.calculatePercentageOutOfTotal(pointsReceived, maxPoints);

		// Return the class based on the performance
		if 		(pointsPercent >= 80) { return "optimal"}
		else if (pointsPercent >= 60) { return "decent"}
		else if (pointsPercent >= 40) { return "neutral"}
		else if (pointsPercent >= 20) { return "warning"}
		else 						  { return "error"}
	}






	/**
	 * Retrieves the absolute value of a number.
	 * @param value 
	 * @returns number
	 */
	private getAbsoluteValue(value: number): number { return value >= 0 ? value: -(value) }
}
